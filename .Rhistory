weatherAU
str(weatherAU)
categorical <- vector()
for (i in 1:(length(weatherAU)-1)) {
if (class(weatherAU[,i]) == "factor") {
category <- colnames(weatherAU)[i]
categorical <- c(categorical, category)
}
}
weatherAU[,categorical] # to be removed
DF <- weatherAU %>%
select(-(categorical)) %>%
select(-c(Date, RISK_MM))
table(DF$RainTomorrow)
library(tidyverse) # for data wrangling
library(caret) # for confusion matrix
library(gtools) # for converting log of odds to probs
library(car) # for executing VIF test
library(rsample) # for splitting dataset into train and test with controlled proportion
library(class) # for KNN
weatherAU <- read.csv("weatherAUS.csv")
weatherAU
categorical <- vector()
weatherAU[,categorical] # to be removed
weatherAU[,categorical] # to be removed
categorical <- vector()
for (i in 1:(length(weatherAU)-1)) {
if (class(weatherAU[,i]) == "factor") {
category <- colnames(weatherAU)[i]
categorical <- c(categorical, category)
}
}
weatherAU[,categorical] # to be removed
DF <- weatherAU %>%
select(-(categorical)) %>%
select(-RISK_MM)
head(DF)
ncol(DF)
colSums(is.na(DF))
cat("\n")
colSums(is.na(DF))/nrow(DF)
for (i in 1:(length(DF)-1)) {
DF[,i] <- replace_na(data = DF[,i], replace = median(DF[,i], na.rm = T))
}
anyNA(DF)
table(DF$RainTomorrow)
prop.table(table(DF$RainTomorrow))
str(DF)
library(PerformanceAnalytics)
chart.Correlation(DF, hist = T)
library(PerformanceAnalytics)
chart.Correlation(DF[,1:16], hist = T)
library(psych)
pairs.panels(redDF)
library(psych)
pairs.panels(DF)
detach("package:PerformanceAnalytics", unload = TRUE)
library(GGally)
ggcorrplot(DF %>% cor(),
hc.order = TRUE, type = "lower",
lab = TRUE,
digits = 1,
ggtheme = ggplot2::theme_dark(),
)
ggcorrplot::ggcorrplot(DF %>% cor(),
hc.order = TRUE, type = "lower",
lab = TRUE,
digits = 1,
ggtheme = ggplot2::theme_dark(),
)
ggcorrplot::ggcorrplot(DF %>% select(-RainTomorrow) %>% cor(),
hc.order = TRUE, type = "lower",
lab = TRUE,
digits = 1,
ggtheme = ggplot2::theme_dark(),
)
GGally::ggcorr(DF %>% select(-RainTomorrow))
GGally::ggcorr(DF %>% select(-RainTomorrow), label = T)
ggcorrplot::ggcorrplot(DF %>% select(-RainTomorrow) %>% cor(),
hc.order = TRUE, type = "lower",
lab = TRUE,
digits = 1,
ggtheme = ggplot2::theme_dark(),
)
cor(DF$Pressure3pm, DF$Pressure9am)
library(psych)
pairs.panels(DF %>% select(-RainTomorrow))
GGally::ggpairs(DF %>% select(-RainTomorrow))
ggcorrplot::ggcorrplot(DF %>% select(-RainTomorrow) %>% cor(),
hc.order = TRUE, type = "lower",
lab = TRUE,
digits = 1,
ggtheme = ggplot2::theme_dark(),
)
cor.test(DF %>% select(-RainTomorrow))
cor.test(DF$MinTemp, DF$MaxTemp)
cor.test(DF$RainTomorrow, DF$MaxTemp)
vec <- setNames(sides, shapes)
shapes<- c("Square", "Triangle","Octagon","Hexagon")
sides<-c(4,3,8,6)
vec <- setNames(sides, shapes)
vec
combn(vec, 2)
combn(vec, 3)
combn(vec, 4)
combn(vec, 5)
combn(vec, 1)
combn(vec, 2)
combn
combn(colnames(DF), 2)
combn(colnames(DF[,1:16]), 2)
dim(combn(colnames(DF[,1:16]), 2))
dim(combn(colnames(DF), 2))
DFcomb <- combn(combn(colnames(DF[,1:16]), 2))
DFcomb <- combn(colnames(DF[,1:16]), 2)
DFcomb
length(Fcomb)
length(DFcomb)
dim(DFcomb)
dim(DFcomb)[2]
DFcomb
head(DF[,"MinTemp"])
DF[,"MinTemp"]
corTest <- cor.test(DF$MinTemp, DF$MaxTemp)
corTest$p.value
corTest
Alpha <- 0.05
for (i in 1:dim(DFcomb)[2]) {
print(paste0("Cor test between ", DFcomb[1,i], " and ", DFcomb[2,i]))
corTest <- cor.test(DF[,DFcomb[1,i]], DF[,DFcomb[2,i]])
ifelse(corTest$p.value < Alpha, "Multicollinear detected", "Safe! No Multicollinear")
cat("\n")
}
for (i in 1:dim(DFcomb)[2]) {
print(paste0("Cor test between ", DFcomb[1,i], " and ", DFcomb[2,i]))
corTest <- cor.test(DF[,DFcomb[1,i]], DF[,DFcomb[2,i]])
ifelse(corTest$p.value < Alpha, print("Multicollinear detected"), print("Safe! No Multicollinear"))
cat("\n")
}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) # for data wrangling
library(caret) # for confusion matrix
library(gtools) # for converting log of odds to probs
library(PerformanceAnalytics) # for pair plotting
library(car) # for executing VIF test
library(rsample) # for splitting dataset into train and test with controlled proportion
library(class) # for KNN
weatherAU <- read.csv("weatherAUS.csv")
weatherAU
str(weatherAU)
categorical <- vector()
for (i in 1:(length(weatherAU)-1)) {
if (class(weatherAU[,i]) == "factor") {
category <- colnames(weatherAU)[i]
categorical <- c(categorical, category)
}
}
weatherAU[,categorical] # to be removed
DF <- weatherAU %>%
select(-(categorical)) %>%
select(-RISK_MM)
head(DF)
ncol(DF)
colSums(is.na(DF))
cat("\n")
colSums(is.na(DF))/nrow(DF)
summary(DF)
DF %>% select(colnames(.)[1:17]) %>%
pivot_longer(cols = colnames(.)[1:16], names_to = "Type", values_to = "Value") %>%
mutate(Type = as.factor(Type)) %>%
ggplot(aes(x = Type,
y = Value)) +
coord_flip() +
geom_boxplot(aes(fill = Type), show.legend = F)
for (i in 1:(length(DF)-1)) {
DF[,i] <- replace_na(data = DF[,i], replace = median(DF[,i], na.rm = T))
}
anyNA(DF)
table(DF$RainTomorrow)
prop.table(table(DF$RainTomorrow))
# library(GGally)
# GGally::ggcorr(DF %>% select(-RainTomorrow), label = T)
ggcorrplot::ggcorrplot(DF %>% select(-RainTomorrow) %>% cor(),
hc.order = TRUE, type = "lower",
lab = TRUE,
digits = 1,
ggtheme = ggplot2::theme_dark(),
)
# GGally::ggpairs(DF %>% select(-RainTomorrow))
# pairs.panels(DF %>% select(-RainTomorrow))
DFcomb <- combn(colnames(DF[,1:16]), 2)
Alpha <- 0.05
for (i in 1:dim(DFcomb)[2]) {
print(paste0("Cor test between ", DFcomb[1,i], " and ", DFcomb[2,i]))
corTest <- cor.test(DF[,DFcomb[1,i]], DF[,DFcomb[2,i]])
ifelse(corTest$p.value < Alpha,
print("Multicollinear detected"),
print("Safe! No Multicollinear"))
cat("\n")
}
set.seed(1)
idx <- initial_split(DF, prop = 0.8, strata = RainTomorrow)
DF_train <- training(idx)
DF_test <- testing(idx)
prop.table(table(DF_train$RainTomorrow)) # Check train dataset proportion after split
prop.table(table(DF_test$RainTomorrow)) # Check test dataset proportion after split
# Split the predictors and the target of train dataset for KNN model usage
X_train <- DF_train[,-ncol(DF_train)]
y_train <- DF_train[,ncol(DF_train)]
# Split the predictors and the target of test dataset for KNN model usage
X_test <- DF_test[,-ncol(DF_test)]
y_test <- DF_test[,ncol(DF_test)]
modelDF_log <- glm(formula = RainTomorrow ~ ., data = DF_train, family = "binomial")
summary(modelDF_log)
X_train.scaled <- scale(x = X_train)
X_test.scaled <- scale(x = X_test,
center = attr(X_train.scaled, "scaled:center"),
scale = attr(X_train.scaled, "scaled:scale"))
predict_log <- predict(object = modelDF_log, newdata = DF_test, type = "response")
K <- sqrt(nrow(X_train))
K
confusionMatrix(data = predict_log, reference = y_test)
predict_log
length(predict_log)
length(y_test)
class(y_test)
class(predict_log)
DF_test$ypred_prob <- predict_log
levels(DF_test$RainTomorrow)
class(DF_test$RainTomorrow)
unique(DF_test$RainTomorrow)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) # for data wrangling
library(caret) # for confusion matrix
library(gtools) # for converting log of odds to probs
library(PerformanceAnalytics) # for pair plotting
library(car) # for executing VIF test
library(rsample) # for splitting dataset into train and test with controlled proportion
library(class) # for KNN
weatherAU <- read.csv("weatherAUS.csv")
weatherAU
str(weatherAU)
categorical <- vector()
for (i in 1:(length(weatherAU)-1)) {
if (class(weatherAU[,i]) == "factor") {
category <- colnames(weatherAU)[i]
categorical <- c(categorical, category)
}
}
weatherAU[,categorical] # to be removed
DF <- weatherAU %>%
select(-(categorical)) %>%
select(-RISK_MM)
head(DF)
ncol(DF)
colSums(is.na(DF))
cat("\n")
colSums(is.na(DF))/nrow(DF)
summary(DF)
DF %>% select(colnames(.)[1:17]) %>%
pivot_longer(cols = colnames(.)[1:16], names_to = "Type", values_to = "Value") %>%
mutate(Type = as.factor(Type)) %>%
ggplot(aes(x = Type,
y = Value)) +
coord_flip() +
geom_boxplot(aes(fill = Type), show.legend = F)
for (i in 1:(length(DF)-1)) {
DF[,i] <- replace_na(data = DF[,i], replace = median(DF[,i], na.rm = T))
}
anyNA(DF)
table(DF$RainTomorrow)
prop.table(table(DF$RainTomorrow))
# library(GGally)
# GGally::ggcorr(DF %>% select(-RainTomorrow), label = T)
ggcorrplot::ggcorrplot(DF %>% select(-RainTomorrow) %>% cor(),
hc.order = TRUE, type = "lower",
lab = TRUE,
digits = 1,
ggtheme = ggplot2::theme_dark(),
)
# GGally::ggpairs(DF %>% select(-RainTomorrow))
# pairs.panels(DF %>% select(-RainTomorrow))
DFcomb <- combn(colnames(DF[,1:16]), 2)
Alpha <- 0.05
for (i in 1:dim(DFcomb)[2]) {
print(paste0("Cor test between ", DFcomb[1,i], " and ", DFcomb[2,i]))
corTest <- cor.test(DF[,DFcomb[1,i]], DF[,DFcomb[2,i]])
ifelse(corTest$p.value < Alpha,
print("Multicollinear detected"),
print("Safe! No Multicollinear"))
cat("\n")
}
set.seed(1)
idx <- initial_split(DF, prop = 0.8, strata = RainTomorrow)
DF_train <- training(idx)
DF_test <- testing(idx)
prop.table(table(DF_train$RainTomorrow)) # Check train dataset proportion after split
prop.table(table(DF_test$RainTomorrow)) # Check test dataset proportion after split
# Split the predictors and the target of train dataset for KNN model usage
X_train <- DF_train[,-ncol(DF_train)]
y_train <- DF_train[,ncol(DF_train)]
# Split the predictors and the target of test dataset for KNN model usage
X_test <- DF_test[,-ncol(DF_test)]
y_test <- DF_test[,ncol(DF_test)]
modelDF_log <- glm(formula = RainTomorrow ~ ., data = DF_train, family = "binomial", )
summary(modelDF_log)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) # for data wrangling
library(caret) # for confusion matrix
library(gtools) # for converting log of odds to probs
library(PerformanceAnalytics) # for pair plotting
library(car) # for executing VIF test
library(rsample) # for splitting dataset into train and test with controlled proportion
library(class) # for KNN
weatherAU <- read.csv("weatherAUS.csv")
weatherAU
str(weatherAU)
categorical <- vector()
for (i in 1:(length(weatherAU)-1)) {
if (class(weatherAU[,i]) == "factor") {
category <- colnames(weatherAU)[i]
categorical <- c(categorical, category)
}
}
weatherAU[,categorical] # to be removed
DF <- weatherAU %>%
select(-(categorical)) %>%
select(-RISK_MM)
head(DF)
ncol(DF)
colSums(is.na(DF))
cat("\n")
colSums(is.na(DF))/nrow(DF)
summary(DF)
# DF %>% select(colnames(.)[1:17]) %>%
#   pivot_longer(cols = colnames(.)[1:16], names_to = "Type", values_to = "Value") %>%
#   mutate(Type = as.factor(Type)) %>%
#   ggplot(aes(x = Type,
#              y = Value)) +
#   coord_flip() +
#   geom_boxplot(aes(fill = Type), show.legend = F)
for (i in 1:(length(DF)-1)) {
DF[,i] <- replace_na(data = DF[,i], replace = median(DF[,i], na.rm = T))
}
anyNA(DF)
table(DF$RainTomorrow)
prop.table(table(DF$RainTomorrow))
# library(GGally)
# GGally::ggcorr(DF %>% select(-RainTomorrow), label = T)
ggcorrplot::ggcorrplot(DF %>% select(-RainTomorrow) %>% cor(),
hc.order = TRUE, type = "lower",
lab = TRUE,
digits = 1,
ggtheme = ggplot2::theme_dark(),
)
# GGally::ggpairs(DF %>% select(-RainTomorrow))
# pairs.panels(DF %>% select(-RainTomorrow))
DFcomb <- combn(colnames(DF[,1:16]), 2)
Alpha <- 0.05
for (i in 1:dim(DFcomb)[2]) {
print(paste0("Cor test between ", DFcomb[1,i], " and ", DFcomb[2,i]))
corTest <- cor.test(DF[,DFcomb[1,i]], DF[,DFcomb[2,i]])
ifelse(corTest$p.value < Alpha,
print("Multicollinear detected"),
print("Safe! No Multicollinear"))
cat("\n")
}
set.seed(1)
idx <- initial_split(DF, prop = 0.8, strata = RainTomorrow)
DF_train <- training(idx)
DF_test <- testing(idx)
prop.table(table(DF_train$RainTomorrow)) # Check train dataset proportion after split
prop.table(table(DF_test$RainTomorrow)) # Check test dataset proportion after split
# Split the predictors and the target of train dataset for KNN model usage
X_train <- DF_train[,-ncol(DF_train)]
y_train <- DF_train[,ncol(DF_train)]
# Split the predictors and the target of test dataset for KNN model usage
X_test <- DF_test[,-ncol(DF_test)]
y_test <- DF_test[,ncol(DF_test)]
modelDF_log <- glm(formula = RainTomorrow ~ ., data = DF_train, family = "binomial")
summary(modelDF_log)
X_train
X_train.scaled <- scale(x = X_train)
X_test.scaled <- scale(x = X_test,
center = attr(X_train.scaled, "scaled:center"),
scale = attr(X_train.scaled, "scaled:scale"))
confusionMatrix(data = predict_log, reference = y_test)
predict_log <- predict(object = modelDF_log, newdata = DF_test, type = "response")
DF_test$ypred_prob <- predict_log
DF_test$ypred_label <- ifelse(DF_test$ypred_prob > 0.5, "Yes", "No")
confusionMatrix(data = predict_log, reference = y_test)
confusionMatrix(data = DF_test$ypred_label, reference = y_test)
y_test
DF_test$ypred_label
y_test
confusionMatrix(data = as.factor(DF_test$ypred_label), reference = y_test)
confusionMatrix(data = as.factor(DF_test$ypred_label), reference = y_test, positive = "Yes")
confusionMatrix(data = as.factor(DF_test$ypred_label), reference = y_test, positive = "No")
predict_log <- predict(object = modelDF_log, newdata = DF_test, type = "response")
DF_test$ypred_prob <- predict_log
DF_test$ypred_label <- ifelse(DF_test$ypred_prob > 0.5, "No", "Yes")
confusionMatrix(data = as.factor(DF_test$ypred_label), reference = y_test, positive = "No")
predict_log <- predict(object = modelDF_log, newdata = DF_test, type = "response")
DF_test$ypred_prob <- predict_log
DF_test$ypred_label <- ifelse(DF_test$ypred_prob > 0.5, "Yes", "No")
confusionMatrix(data = as.factor(DF_test$ypred_label), reference = y_test, positive = "Yes")
AUC(DF_test$ypred_label, y_true = y_test)
MLmetrics::AUC(DF_test$ypred_label, y_true = y_test)
predict_log
as.numeric(y_test == "Yes")
y_test[1]
as.numeric(y_test == "Yes")
y_test[4:5]
df_ <- data.frame("prediction" = predict_log,
"trueclass" = as.numeric(y_test == "Yes"))
df__roc <- ROCR::prediction(df_$prediction, df_$trueclass)
plot(performance(df__roc, "tpr", "fpr"))
plot(ROCR::performance(df__roc, "tpr", "fpr"))
df__roc <- ROCR::prediction(df_$prediction, df_$trueclass)
df__roc
library(ROCR)
df_ <- data.frame("prediction" = predict_log,
"trueclass" = as.numeric(y_test == "Yes"))
df__roc <- prediction(df_$prediction, df_$trueclass)
plot(performance(df__roc, "tpr", "fpr"))
ROCR::performance(prediction.obj = df__roc, measure = "auc")
ROCR::performance(prediction.obj = df__roc, "auc")
auc <- ROCR::performance(prediction.obj = df__roc, "auc")
auc
auc@y.values[[1]]
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) # for data wrangling
library(caret) # for confusion matrix
library(gtools) # for converting log of odds to probs
library(PerformanceAnalytics) # for pair plotting
library(car) # for executing VIF test
library(rsample) # for splitting dataset into train and test with controlled proportion
library(class) # for KNN
weatherAU <- read.csv("weatherAUS.csv")
weatherAU
str(weatherAU)
categorical <- vector()
for (i in 1:(length(weatherAU)-1)) {
if (class(weatherAU[,i]) == "factor") {
category <- colnames(weatherAU)[i]
categorical <- c(categorical, category)
}
}
weatherAU[,categorical] # to be removed
DF <- weatherAU %>%
select(-(categorical)) %>%
select(-RISK_MM)
head(DF)
ncol(DF)
colSums(is.na(DF))
cat("\n")
colSums(is.na(DF))/nrow(DF)
summary(DF)
# DF %>% select(colnames(.)[1:17]) %>%
#   pivot_longer(cols = colnames(.)[1:16], names_to = "Type", values_to = "Value") %>%
#   mutate(Type = as.factor(Type)) %>%
#   ggplot(aes(x = Type,
#              y = Value)) +
#   coord_flip() +
#   geom_boxplot(aes(fill = Type), show.legend = F)
for (i in 1:(length(DF)-1)) {
DF[,i] <- replace_na(data = DF[,i], replace = median(DF[,i], na.rm = T))
}
anyNA(DF)
table(DF$RainTomorrow)
prop.table(table(DF$RainTomorrow))
# library(GGally)
# GGally::ggcorr(DF %>% select(-RainTomorrow), label = T)
ggcorrplot::ggcorrplot(DF %>% select(-RainTomorrow) %>% cor(),
hc.order = TRUE, type = "lower",
lab = TRUE,
digits = 1,
ggtheme = ggplot2::theme_dark(),
)
# GGally::ggpairs(DF %>% select(-RainTomorrow))
# pairs.panels(DF %>% select(-RainTomorrow))
DFcomb <- combn(colnames(DF[,1:16]), 2)
Alpha <- 0.05
for (i in 1:dim(DFcomb)[2]) {
print(paste0("Cor test between ", DFcomb[1,i], " and ", DFcomb[2,i]))
corTest <- cor.test(DF[,DFcomb[1,i]], DF[,DFcomb[2,i]])
ifelse(corTest$p.value < Alpha,
print("Multicollinear detected"),
print("Safe! No Multicollinear"))
cat("\n")
}
set.seed(1)
idx <- initial_split(DF, prop = 0.8, strata = RainTomorrow)
DF_train <- training(idx)
DF_test <- testing(idx)
prop.table(table(DF_train$RainTomorrow)) # Check train dataset proportion after split
prop.table(table(DF_test$RainTomorrow)) # Check test dataset proportion after split
# Split the predictors and the target of train dataset for KNN model usage
X_train <- DF_train[,-ncol(DF_train)]
y_train <- DF_train[,ncol(DF_train)]
# Split the predictors and the target of test dataset for KNN model usage
X_test <- DF_test[,-ncol(DF_test)]
y_test <- DF_test[,ncol(DF_test)]
modelDF_log <- glm(formula = RainTomorrow ~ ., data = DF_train, family = "binomial")
summary(modelDF_log)
X_train.scaled <- scale(x = X_train)
X_test.scaled <- scale(x = X_test,
center = attr(X_train.scaled, "scaled:center"),
scale = attr(X_train.scaled, "scaled:scale"))
predict_log <- predict(object = modelDF_log, newdata = DF_test, type = "response")
DF_test$ypred_prob <- predict_log
DF_test$ypred_label <- ifelse(DF_test$ypred_prob > 0.5, "Yes", "No")
