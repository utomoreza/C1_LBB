multicolRes$cor[i] <- corTest$p.value
multicolRes$res[i] <- ifelse(corTest$p.value < Alpha,
"Yes",
"No")
# multiResults <- c(multiResults, res)
}
sonarComb
idx <- c(1, seq(from = 4, to = ncol(temp), by = 4))
idx
DF
sonarComb <- combn(colnames(DF[,-ncol(DF)]), 2) # create combinations among each variable
Alpha <- 0.05 # set significance value
multicolRes <- data.frame(vs = 1:dim(sonarComb)[2], # create a blank data frame
cor = 1:dim(sonarComb)[2],
res = 1:dim(sonarComb)[2])
for (i in 1:dim(sonarComb)[2]) {
multicolRes$vs[i] <- paste0(sonarComb[1,i], " & ", sonarComb[2,i])
corTest <- cor.test(DF[,sonarComb[1,i]], DF[,sonarComb[2,i]])
multicolRes$cor[i] <- corTest$p.value
multicolRes$res[i] <- ifelse(corTest$p.value < Alpha,
"Yes",
"No")
# multiResults <- c(multiResults, res)
}
head(multicolRes)
table(multicolRes$res)
multicolRes[multicolRes$res == "No",]
idx <- c(1, seq(from = 5, to = ncol(temp), by = 5))
ggcorr(temp[,idx], label = T)
DF <- sonar[,c(idx,61)] # subset only necessary columns, i.e. the multipl of 4
sonarComb <- combn(colnames(DF[,-ncol(DF)]), 2) # create combinations among each variable
Alpha <- 0.05 # set significance value
multicolRes <- data.frame(vs = 1:dim(sonarComb)[2], # create a blank data frame
cor = 1:dim(sonarComb)[2],
res = 1:dim(sonarComb)[2])
for (i in 1:dim(sonarComb)[2]) {
multicolRes$vs[i] <- paste0(sonarComb[1,i], " & ", sonarComb[2,i])
corTest <- cor.test(DF[,sonarComb[1,i]], DF[,sonarComb[2,i]])
multicolRes$cor[i] <- corTest$p.value
multicolRes$res[i] <- ifelse(corTest$p.value < Alpha,
"Yes",
"No")
# multiResults <- c(multiResults, res)
}
head(multicolRes)
table(multicolRes$res)
prop.table(table(multicolRes$res))
idx <- c(1, seq(from = 3, to = ncol(temp), by = 3))
ggcorr(temp[,idx], label = T)
DF <- sonar[,c(idx,61)] # subset only necessary columns, i.e. the multipl of 4
sonarComb <- combn(colnames(DF[,-ncol(DF)]), 2) # create combinations among each variable
Alpha <- 0.05 # set significance value
multicolRes <- data.frame(vs = 1:dim(sonarComb)[2], # create a blank data frame
cor = 1:dim(sonarComb)[2],
res = 1:dim(sonarComb)[2])
for (i in 1:dim(sonarComb)[2]) {
multicolRes$vs[i] <- paste0(sonarComb[1,i], " & ", sonarComb[2,i])
corTest <- cor.test(DF[,sonarComb[1,i]], DF[,sonarComb[2,i]])
multicolRes$cor[i] <- corTest$p.value
multicolRes$res[i] <- ifelse(corTest$p.value < Alpha,
"Yes",
"No")
# multiResults <- c(multiResults, res)
}
head(multicolRes)
table(multicolRes$res)
prop.table(table(multicolRes$res))
idx <- c(1, seq(from = 6, to = ncol(temp), by = 6))
ggcorr(temp[,idx], label = T)
DF <- sonar[,c(idx,61)] # subset only necessary columns, i.e. the multipl of 4
sonarComb <- combn(colnames(DF[,-ncol(DF)]), 2) # create combinations among each variable
Alpha <- 0.05 # set significance value
multicolRes <- data.frame(vs = 1:dim(sonarComb)[2], # create a blank data frame
cor = 1:dim(sonarComb)[2],
res = 1:dim(sonarComb)[2])
for (i in 1:dim(sonarComb)[2]) {
multicolRes$vs[i] <- paste0(sonarComb[1,i], " & ", sonarComb[2,i])
corTest <- cor.test(DF[,sonarComb[1,i]], DF[,sonarComb[2,i]])
multicolRes$cor[i] <- corTest$p.value
multicolRes$res[i] <- ifelse(corTest$p.value < Alpha,
"Yes",
"No")
# multiResults <- c(multiResults, res)
}
head(multicolRes)
table(multicolRes$res)
prop.table(table(multicolRes$res))
DF <- sonar#sonar[,c(idx,61)] # subset only necessary columns, i.e. the multipl of 4
sonarComb <- combn(colnames(DF[,-ncol(DF)]), 2) # create combinations among each variable
Alpha <- 0.05 # set significance value
multicolRes <- data.frame(vs = 1:dim(sonarComb)[2], # create a blank data frame
cor = 1:dim(sonarComb)[2],
res = 1:dim(sonarComb)[2])
for (i in 1:dim(sonarComb)[2]) {
multicolRes$vs[i] <- paste0(sonarComb[1,i], " & ", sonarComb[2,i])
corTest <- cor.test(DF[,sonarComb[1,i]], DF[,sonarComb[2,i]])
multicolRes$cor[i] <- corTest$p.value
multicolRes$res[i] <- ifelse(corTest$p.value < Alpha,
"Yes",
"No")
# multiResults <- c(multiResults, res)
}
head(multicolRes)
table(multicolRes$res)
prop.table(table(multicolRes$res))
multicolRes[multicolRes$res == "No",]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy1", x = multicolRes$vs),]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy1 ", x = multicolRes$vs),]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy1 {1}", x = multicolRes$vs),]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy1 {2}", x = multicolRes$vs),]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy1 {1}", x = multicolRes$vs),]
grepl(pattern = "energy1 {1}", x = multicolRes$vs)
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy1 {1}", x = multicolRes$vs)[1],]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy1 {1}", x = multicolRes$vs),]
grepl(pattern = "energy[1-9] {1}", x = multicolRes$vs)[1]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy[1-9] {1}", x = multicolRes$vs),]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy[1-2] {1}", x = multicolRes$vs),]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy[2-3] {1}", x = multicolRes$vs),]
multicolRes[multicolRes$res == "No" & grepl(pattern = "energy[1-9] ", x = multicolRes$vs),]
multicolRes[multicolRes$res == "No",]
grep(pattern = "energy[1-9] {1}", x = multicolRes$vs)
grep(pattern = "energy1 ", x = multicolRes$vs)
grep(pattern = "energy1 ", x = multicolRes$vs)[1]
temp <- multicolRes[multicolRes$res == "No",]
temp
temp[17,]
temp
grep(pattern = "energy1 ", x = multicolRes$vs)[1]
temp[1,]
temp
grep(pattern = "energy2 ", x = multicolRes$vs)[1]
temp[60,]
multicolRes[60,]
grep(pattern = "energy2 ", x = temp$vs)[1]
temp[15,]
temp
index(temp)
temp <- multicolRes[multicolRes$res == "No",]
rownames(temp) <- NULL
temp
grep(pattern = "energy2 ", x = temp$vs)[1]
temp[15,]
indices <- vector()
temp <- multicolRes[multicolRes$res == "No",]
rownames(temp) <- NULL
for (i in 1:nrow(temp)) {
idx <- grep(pattern = paste0("energy", i, " "), x = temp$vs)[1]
indices <- c(indices, idx)
}
temp[indices,]
indices
1:nrow(temp)
for (i in 1:60) {
idx <- grep(pattern = paste0("energy", i, " "), x = temp$vs)[1]
indices <- c(indices, idx)
}
indices
i
grep(pattern = paste0("energy", i, " "), x = temp$vs)[1]
temp
temp[nrow(temp),]
temp[nrow(temp),]$vs
grep("^energy", x = temp[nrow(temp),]$vs)
grep("^energy ", x = temp[nrow(temp),]$vs)
regexpr("^energy ", x = temp[nrow(temp),]$vs)
regexpr("^energy", x = temp[nrow(temp),]$vs)
regexpr("^energy", text = temp[nrow(temp),]$vs)
regexpr("^energy ", text = temp[nrow(temp),]$vs)
regexpr("^energy", text = temp[nrow(temp),]$vs)
regexpr("energy", text = temp[nrow(temp),]$vs)
regexpr("e", text = temp[nrow(temp),]$vs)
regexec("e", text = temp[nrow(temp),]$vs)
gregexpr("energy", text = temp[nrow(temp),]$vs)
str_match(string = temp[nrow(temp),]$vs, pattern = "energy")
temp[nrow(temp),]$vs
temp[nrow(temp),]$vs
str_match(string = temp[nrow(temp),]$vs, pattern = "^energy")
temp[nrow(temp),]$vs
str_match(string = temp[nrow(temp),]$vs, pattern = "^aa")
str_match(string = temp[nrow(temp),]$vs, pattern = "^energy(.*?) &")
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^energy(.*?) &")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.*?) &")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{4}y(.*?) &")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.*?) &")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.*?) \\&")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.?) \\&")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(*?) \\&")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.*) \\&")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.{1}) \\&")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.{2}) \\&")
a
a <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.{1,2}) \\&")
a
a[1,2]
indices <- vector()
temp <- multicolRes[multicolRes$res == "No",]
lastEnergy <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.{1,2}) \\&")
lastEnergy <- lastEnergy[1,2]
rownames(temp) <- NULL
for (i in 1:lastEnergy) {
idx <- grep(pattern = paste0("energy", i, " "), x = temp$vs)[1]
indices <- c(indices, idx)
}
temp[indices,]
temp
indices <- vector()
temp <- multicolRes[multicolRes$res == "No",]
lastEnergy <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.{1,2}) \\&")
lastEnergy <- lastEnergy[1,2]
rownames(temp) <- NULL
for (i in 1:lastEnergy) {
idx <- grep(pattern = paste0("energy", i, " "), x = temp$vs)[1]
indices <- c(indices, idx)
}
indices <- drop_na(indices)
drop_na(indices)
indices <- vector()
temp <- multicolRes[multicolRes$res == "No",]
lastEnergy <- str_match(string = temp[nrow(temp),]$vs, pattern = "^[a-z]{5}y(.{1,2}) \\&")
lastEnergy <- lastEnergy[1,2]
rownames(temp) <- NULL
for (i in 1:lastEnergy) {
idx <- grep(pattern = paste0("energy", i, " "), x = temp$vs)[1]
indices <- c(indices, idx)
}
indices <- indices[!is.na(indices)]
temp[indices,]
idx <- c(1, seq(from = 6, to = ncol(temp), by = 6))
idx <- c(1, seq(from = 4, to = ncol(temp), by = 4))
temp <- sonar %>% select(-type)
colnames(temp) <- c(1:60)
ggcorrplot(temp %>% cor())
idx <- c(1, seq(from = 4, to = ncol(temp), by = 4))
ggcorr(temp[,idx], label = T)
DF <- sonar[,c(idx,61)] # subset only necessary columns, i.e. the multipl of 4
sonarComb <- combn(colnames(DF[,-ncol(DF)]), 2) # create combinations among each variable
Alpha <- 0.05 # set significance value
multicolRes <- data.frame(vs = 1:dim(sonarComb)[2], # create a blank data frame
cor = 1:dim(sonarComb)[2],
res = 1:dim(sonarComb)[2])
for (i in 1:dim(sonarComb)[2]) {
multicolRes$vs[i] <- paste0(sonarComb[1,i], " & ", sonarComb[2,i])
corTest <- cor.test(DF[,sonarComb[1,i]], DF[,sonarComb[2,i]])
multicolRes$cor[i] <- corTest$p.value
multicolRes$res[i] <- ifelse(corTest$p.value < Alpha,
"Yes",
"No")
# multiResults <- c(multiResults, res)
}
head(multicolRes)
table(multicolRes$res)
prop.table(table(multicolRes$res))
predict_knn_prob <- knn(train = X_train.scaled, test = X_test.scaled, cl = y_train, k = round(K), prob = T)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) # for data wrangling
library(plotly) # for plotting using plotly style
library(ggcorrplot) # for plotting correlation
library(GGally) # for plotting correlation
library(caret) # for confusion matrix
library(gtools) # for converting log of odds to probs
library(PerformanceAnalytics) # for pair plotting
library(car) # for executing VIF test
library(rsample) # for splitting dataset into train and test with controlled proportion
library(class) # for KNN
library(ROCR) # for calculating ROC
library(MLmetrics) # for calculating accuracy
sonar <- read.csv("sonar.all-data", header = F)
head(sonar)
colnames(sonar) <- c(paste0("energy",c(1:60)), "type")
head(sonar)
anyNA(sonar)
str(sonar)
table(sonar$type)
prop.table(table(sonar$type))
summary(sonar)
p <- sonar %>% select(colnames(.)[-61]) %>%
pivot_longer(cols = colnames(.), names_to = "Energy", values_to = "Value") %>%
arrange(Energy) %>%
mutate(Energy = as.factor(Energy)) %>%
ggplot(aes(x = Energy,
y = Value)) +
coord_flip() +
geom_boxplot(aes(fill = Energy), show.legend = F) +
theme(axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
legend.position = "none")
ggplotly(p)
temp <- sonar %>% select(-type)
colnames(temp) <- c(1:60)
ggcorrplot(temp %>% cor())
idx <- c(1, seq(from = 4, to = ncol(temp), by = 4))
ggcorr(temp[,idx], label = T)
DF <- sonar[,c(idx,61)] # subset only necessary columns, i.e. the multipl of 4
sonarComb <- combn(colnames(DF[,-ncol(DF)]), 2) # create combinations among each variable
Alpha <- 0.05 # set significance value
multicolRes <- data.frame(vs = 1:dim(sonarComb)[2], # create a blank data frame
cor = 1:dim(sonarComb)[2],
res = 1:dim(sonarComb)[2])
for (i in 1:dim(sonarComb)[2]) {
multicolRes$vs[i] <- paste0(sonarComb[1,i], " & ", sonarComb[2,i])
corTest <- cor.test(DF[,sonarComb[1,i]], DF[,sonarComb[2,i]])
multicolRes$cor[i] <- corTest$p.value
multicolRes$res[i] <- ifelse(corTest$p.value < Alpha,
"Yes",
"No")
# multiResults <- c(multiResults, res)
}
head(multicolRes)
table(multicolRes$res)
prop.table(table(multicolRes$res))
set.seed(1)
idx <- initial_split(DF, prop = 0.8, strata = type)
sonar_train <- training(idx)
sonar_test <- testing(idx)
prop.table(table(sonar_train$type)) # Check train dataset proportion after split
prop.table(table(sonar_test$type)) # Check test dataset proportion after split
# Split the predictors and the target of train dataset for KNN model usage
X_train <- sonar_train[,-ncol(sonar_train)]
y_train <- sonar_train[,ncol(sonar_train)]
# Split the predictors and the target of test dataset for KNN model usage
X_test <- sonar_test[,-ncol(sonar_test)]
y_test <- sonar_test[,ncol(sonar_test)]
model_log <- glm(formula = type ~ ., data = sonar_train, family = "binomial", maxit = 30)
summary(model_log)
X_train.scaled <- scale(x = X_train)
X_test.scaled <- scale(x = X_test,
center = attr(X_train.scaled, "scaled:center"),
scale = attr(X_train.scaled, "scaled:scale"))
predict_log <- predict(object = model_log, newdata = sonar_test, type = "response")
sonar_test$ypred_prob <- predict_log
sonar_test$ypred_label <- ifelse(sonar_test$ypred_prob > 0.5, "R", "M")
# negative class is M
# positive class is R
# since at the beginning, R automatically sets "M" as the first as class, meaning the negative class
K <- sqrt(nrow(X_train))
K
predict_knn <- knn(train = X_train.scaled, test = X_test.scaled, cl = y_train, k = round(K))
predict_knn_prob <- knn(train = X_train.scaled, test = X_test.scaled, cl = y_train, k = round(K), prob = T)
predict_knn_prob
class(predict_knn_prob)
predict_knn_prob[1]
attr(predict_knn_prob)
attr(predict_knn_prob, which = "prob")
predict_knn <- knn(train = X_train.scaled, test = X_test.scaled, cl = y_train, k = round(K))
# get probability values of KNN predictions
knn_prob <- knn(train = X_train.scaled, test = X_test.scaled, cl = y_train, k = round(K), prob = T)
predict_knnProb <- attr(knn_prob, which = "prob")
options(scipen = 999)
df_ <- data.frame("pred_LogRes" = predict_log,
"pred_KNN" = predict_knnProb,
"trueclass" = as.numeric(y_test == "R"))
LogResROC <- prediction(df_$pred_LogRes, df_$trueclass)
perfLogRes <- performance(LogResROC, "tpr", "fpr")
KNN.ROC <- prediction(df_$pred_KNN, df_$trueclass)
perfKNN <- performance(KNN.ROC, "tpr", "fpr")
rocDF.LogRes <- data.frame(threshold = perfLogRes@alpha.values[[1]],
tpr = perfLogRes@y.values[[1]],
fpr = perfLogRes@x.values[[1]])
rocDF.KNN <- data.frame(threshold = perfKNN@alpha.values[[1]],
tpr = perfKNN@y.values[[1]],
fpr = perfKNN@x.values[[1]])
ggplot(rocDF.LogRes, aes(x = fpr, y = tpr)) +
geom_line(color = "blue") +
geom_point(color = "black") +
geom_line(data = rocDF.KNN, aes(x = fpr, y = tpr), color = "red") +
geom_point(data = rocDF.KNN, aes(x = fpr, y = tpr), color = "black") +
geom_abline(color = "grey", intercept = 0, slope = 1, linetype="dashed") +
labs(main = "Receiver operating characteristic curve",
x = "False positive rate",
y = "True positive rate")
ggplot(rocDF.LogRes, aes(x = fpr, y = tpr)) +
geom_line(color = "blue") +
geom_point(color = "black") +
# geom_line(data = rocDF.KNN, aes(x = fpr, y = tpr), color = "red") +
# geom_point(data = rocDF.KNN, aes(x = fpr, y = tpr), color = "black") +
geom_abline(color = "grey", intercept = 0, slope = 1, linetype="dashed") +
labs(main = "Receiver operating characteristic curve",
x = "False positive rate",
y = "True positive rate")
confusionMatrix(data = as.factor(sonar_test$ypred_label), reference = y_test, positive = "R")
# show AUC value
auc <- ROCR::performance(prediction.obj = LogResROC, "auc")
auc@y.values[[1]]
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) # for data wrangling
library(plotly) # for plotting using plotly style
library(ggcorrplot) # for plotting correlation
library(GGally) # for plotting correlation
library(caret) # for confusion matrix
library(gtools) # for converting log of odds to probs
library(PerformanceAnalytics) # for pair plotting
library(car) # for executing VIF test
library(rsample) # for splitting dataset into train and test with controlled proportion
library(class) # for KNN
library(ROCR) # for calculating ROC
library(MLmetrics) # for calculating accuracy
sonar <- read.csv("sonar.all-data", header = F)
head(sonar)
colnames(sonar) <- c(paste0("energy",c(1:60)), "type")
head(sonar)
anyNA(sonar)
str(sonar)
table(sonar$type)
prop.table(table(sonar$type))
summary(sonar)
p <- sonar %>% select(colnames(.)[-61]) %>%
pivot_longer(cols = colnames(.), names_to = "Energy", values_to = "Value") %>%
arrange(Energy) %>%
mutate(Energy = as.factor(Energy)) %>%
ggplot(aes(x = Energy,
y = Value)) +
coord_flip() +
geom_boxplot(aes(fill = Energy), show.legend = F) +
theme(axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
legend.position = "none")
ggplotly(p)
temp <- sonar %>% select(-type)
colnames(temp) <- c(1:60)
ggcorrplot(temp %>% cor())
idx <- c(1, seq(from = 4, to = ncol(temp), by = 4))
ggcorr(temp[,idx], label = T)
DF <- sonar[,c(idx,61)] # subset only necessary columns, i.e. the multipl of 4
sonarComb <- combn(colnames(DF[,-ncol(DF)]), 2) # create combinations among each variable
Alpha <- 0.05 # set significance value
multicolRes <- data.frame(vs = 1:dim(sonarComb)[2], # create a blank data frame
cor = 1:dim(sonarComb)[2],
res = 1:dim(sonarComb)[2])
for (i in 1:dim(sonarComb)[2]) {
multicolRes$vs[i] <- paste0(sonarComb[1,i], " & ", sonarComb[2,i])
corTest <- cor.test(DF[,sonarComb[1,i]], DF[,sonarComb[2,i]])
multicolRes$cor[i] <- corTest$p.value
multicolRes$res[i] <- ifelse(corTest$p.value < Alpha,
"Yes",
"No")
# multiResults <- c(multiResults, res)
}
head(multicolRes)
table(multicolRes$res)
prop.table(table(multicolRes$res))
set.seed(1)
idx <- initial_split(DF, prop = 0.8, strata = type)
sonar_train <- training(idx)
sonar_test <- testing(idx)
prop.table(table(sonar_train$type)) # Check train dataset proportion after split
prop.table(table(sonar_test$type)) # Check test dataset proportion after split
# Split the predictors and the target of train dataset for KNN model usage
X_train <- sonar_train[,-ncol(sonar_train)]
y_train <- sonar_train[,ncol(sonar_train)]
# Split the predictors and the target of test dataset for KNN model usage
X_test <- sonar_test[,-ncol(sonar_test)]
y_test <- sonar_test[,ncol(sonar_test)]
model_log <- glm(formula = type ~ ., data = sonar_train, family = "binomial", maxit = 30)
summary(model_log)
X_train.scaled <- scale(x = X_train)
X_test.scaled <- scale(x = X_test,
center = attr(X_train.scaled, "scaled:center"),
scale = attr(X_train.scaled, "scaled:scale"))
predict_log <- predict(object = model_log, newdata = sonar_test, type = "response")
sonar_test$ypred_prob <- predict_log
sonar_test$ypred_label <- ifelse(sonar_test$ypred_prob > 0.5, "R", "M")
# negative class is M
# positive class is R
# since at the beginning, R automatically sets "M" as the first as class, meaning the negative class
K <- sqrt(nrow(X_train))
K
predict_knn <- knn(train = X_train.scaled, test = X_test.scaled, cl = y_train, k = round(K))
# get probability values of KNN predictions
knn_prob <- knn(train = X_train.scaled, test = X_test.scaled, cl = y_train, k = round(K), prob = T)
predict_knnProb <- attr(knn_prob, which = "prob")
print("Confusion Matrix of Log Regression Model")
confusionMatrix(data = as.factor(sonar_test$ypred_label), reference = y_test, positive = "R")
print("Confusion Matrix of KNN")
confusionMatrix(data = predict_knn, reference = y_test, positive = "R")
options(scipen = 999)
df_ <- data.frame("pred_LogRes" = predict_log,
"pred_KNN" = predict_knnProb,
"trueclass" = as.numeric(y_test == "R"))
df_ <- data.frame("pred_LogRes" = predict_log,
"pred_KNN" = predict_knnProb,
"trueclass" = as.numeric(y_test == "R"))
df_
knn_prob
predict_knn
predict_knn == knn_prob
predict_knnProb
predict_knnProb
predict_knn
predict_knnProb
ifelse(predict_knnProb >= 0.85, "R", "M")
predict_knn
predict_knnProb
ifelse(predict_knnProb >= 0.85, as.factor("R"), as.factor("M"))
predict_knn
predict_knnProb
ifelse(predict_knnProb >= 0.85, "R", "M")
predict_knn
predict_knnProb
ifelse(predict_knnProb >= 0.85, "R", "M")
as.character.factor(predict_knn)
predict_knnProb
as.character.factor(predict_knn) == ifelse(predict_knnProb >= 0.85, "R", "M")
